package main

import (
	"github.com/metaleap/go-util/dev/ps"
	"github.com/metaleap/go-util/str"
)

/*
Represents everything in coreimp.json files
generated by purs with the --dump-coreimp option.

In here we mostly deal with the stuff in Body
(the actual JS-like core-imperative AST ie funcs + vars),
whereas DeclAnns and DeclEnv (PureScript types &
signatures) are mostly handled in ps-coreimp-decls.go.
*/

type psCoreImp struct { // we skip unmarshaling what isn't used for now, but DO keep these around commented-out:
	udevps.CoreImp
	mod *modPkg
}

func (me *psCoreImp) forceAstIntoIrABlock(cia *udevps.CoreImpAst, into *irABlock) {
	switch maybebody := me.astToIrA(cia).(type) {
	case *irABlock:
		into.Body = maybebody.Body
		for _, a := range into.Body {
			a.Base().parent = into
		}
	default:
		into.add(maybebody)
	}
}

func (me *psCoreImp) astToIrA(cia *udevps.CoreImpAst) (a irA) {
	istopleveldecl := (cia.Parent == nil)
	switch cia.AstTag {
	case "StringLiteral":
		a = ªS(cia.StringLiteral)
	case "BooleanLiteral":
		a = ªB(cia.BooleanLiteral)
	case "NumberLiteral":
		a = ªN(cia.NumberLiteral)
	case "IntegerLiteral":
		a = ªI(cia.IntegerLiteral)
	case "Var":
		v := ªSymPs(cia.Var, me.mod.irMeta.hasExport(cia.Var))
		a = v
	case "Block":
		b := ªBlock()
		for _, c := range cia.Block {
			b.add(me.astToIrA(c))
		}
		a = b
	case "While":
		f := ªFor()
		f.ForCond = me.astToIrA(cia.While)
		f.ForCond.Base().parent = f
		me.forceAstIntoIrABlock(cia.AstBody, f.ForDo)
		a = f
	case "ForIn":
		f := ªFor()
		f.ForRange = ªLet("", cia.ForIn, me.astToIrA(cia.AstFor1))
		f.ForRange.parent = f
		me.forceAstIntoIrABlock(cia.AstBody, f.ForDo)
		a = f
	case "For":
		f := ªFor()
		fs := ªSymPs(cia.For, me.mod.irMeta.hasExport(cia.For))
		f.ForInit = []*irALet{ªLet("", cia.For, me.astToIrA(cia.AstFor1))}
		f.ForInit[0].parent = f
		fscmp, fsset, fsadd := *fs, *fs, *fs // quirky that we need these copies but we do
		f.ForCond = ªO2(&fscmp, "<", me.astToIrA(cia.AstFor2))
		f.ForCond.Base().parent = f
		f.ForStep = []*irASet{ªSet(&fsset, ªO2(&fsadd, "+", ªI(1)))}
		f.ForStep[0].parent = f
		me.forceAstIntoIrABlock(cia.AstBody, f.ForDo)
		a = f
	case "IfElse":
		i := ªIf(me.astToIrA(cia.IfElse))
		me.forceAstIntoIrABlock(cia.AstThen, i.Then)
		if cia.AstElse != nil {
			i.Else = ªBlock()
			me.forceAstIntoIrABlock(cia.AstElse, i.Else)
			i.Else.parent = i
		}
		a = i
	case "App":
		c := ªCall(me.astToIrA(cia.App))
		for _, carg := range cia.AstApplArgs {
			arg := me.astToIrA(carg)
			arg.Base().parent = c
			c.CallArgs = append(c.CallArgs, arg)
		}
		a = c
	case "VariableIntroduction":
		v := ªLet("", cia.VariableIntroduction, nil)
		var wastypefunc *irAFunc
		if cia.AstRight != nil {
			v.LetVal = me.astToIrA(cia.AstRight)
			vlvb := v.LetVal.Base()
			vlvb.parent = v
			if v.LetVal != nil && vlvb.RefFunc != nil {
				if istopleveldecl && ustr.BeginsUpper(cia.VariableIntroduction) {
					wastypefunc = v.LetVal.(*irAFunc)
				}
			} else if vlvc, _ := v.LetVal.(*irACall); vlvc != nil {
				if vlvcb := vlvc.Callee.Base(); vlvcb.RefFunc != nil {
					if istopleveldecl && ustr.BeginsUpper(cia.VariableIntroduction) {
						wastypefunc = vlvc.Callee.(*irAFunc)
					}
				}
			}
		}
		if wastypefunc != nil {
			a = &irACtor{irAFunc: *wastypefunc}
		} else {
			a = v
		}
	case "Function":
		wastypefunc := istopleveldecl && cia.Function != "" && ustr.BeginsUpper(cia.Function)
		f := ªFunc()
		f.RefFunc = &irATypeRefFunc{}
		f.setBothNamesFromPsName(cia.Function)
		for _, fpn := range cia.AstFuncParams {
			arg := &irANamedTypeRef{}
			arg.setBothNamesFromPsName(fpn)
			f.RefFunc.Args = append(f.RefFunc.Args, arg)
		}
		f.RefFunc.impl = f.FuncImpl
		me.forceAstIntoIrABlock(cia.AstBody, f.FuncImpl)
		if wastypefunc {
			a = &irACtor{irAFunc: *f}
		} else {
			a = f
		}
	case "Unary":
		o := ªO1(cia.AstOp, me.astToIrA(cia.Unary))
		switch o.Op1 {
		case "Negate":
			o.Op1 = "-"
		case "Not":
			o.Op1 = "!"
		case "Positive":
			o.Op1 = "+"
		case "BitwiseNot":
			o.Op1 = "^"
		case "New":
			o.Op1 = "&"
		default:
			panic(notImplErr("Unary", o.Op1, cia.Root.My.ImpFilePath))
		}
		a = o
	case "Binary":
		o := ªO2(me.astToIrA(cia.Binary), cia.AstOp, me.astToIrA(cia.AstRight))
		switch o.Op2 {
		case "Add":
			o.Op2 = "+"
		case "Subtract":
			o.Op2 = "-"
		case "Multiply":
			o.Op2 = "*"
		case "Divide":
			o.Op2 = "/"
		case "Modulus":
			o.Op2 = "%"
		case "EqualTo":
			o.Op2 = "=="
		case "NotEqualTo":
			o.Op2 = "!="
		case "LessThan":
			o.Op2 = "<"
		case "LessThanOrEqualTo":
			o.Op2 = "<="
		case "GreaterThan":
			o.Op2 = ">"
		case "GreaterThanOrEqualTo":
			o.Op2 = ">="
		case "And":
			o.Op2 = "&&"
		case "Or":
			o.Op2 = "||"
		case "BitwiseAnd":
			o.Op2 = "&"
		case "BitwiseOr":
			o.Op2 = "|"
		case "BitwiseXor":
			o.Op2 = "^"
		case "ShiftLeft":
			o.Op2 = "<<"
		case "ShiftRight":
			o.Op2 = ">>"
		case "ZeroFillShiftRight":
			o.Op2 = "&^"
		default:
			panic(notImplErr("Binary", o.Op2, cia.Root.My.ImpFilePath))
		}
		a = o
	case "Comment":
		c := ªComments(cia.Comment...)
		a = c
	case "ObjectLiteral":
		o := ªO(nil)
		for _, namevaluepair := range cia.ObjectLiteral {
			for onekey, oneval := range namevaluepair {
				ofv := ªOFld(me.astToIrA(oneval))
				ofv.setBothNamesFromPsName(onekey)
				ofv.parent = o
				o.ObjFields = append(o.ObjFields, ofv)
				break
			}
		}
		a = o
	case "ReturnNoResult":
		r := ªRet(nil)
		a = r
	case "Return":
		r := ªRet(me.astToIrA(cia.Return))
		a = r
	case "Throw":
		r := ªPanic(me.astToIrA(cia.Throw))
		a = r
	case "ArrayLiteral":
		exprs := make([]irA, 0, len(cia.ArrayLiteral))
		for _, v := range cia.ArrayLiteral {
			exprs = append(exprs, me.astToIrA(v))
		}
		l := ªA(exprs...)
		a = l
	case "Assignment":
		o := ªSet(me.astToIrA(cia.Assignment), me.astToIrA(cia.AstRight))
		a = o
	case "Indexer":
		if cia.AstRight.AstTag != "StringLiteral" {
			a = ªIndex(me.astToIrA(cia.Indexer), me.astToIrA(cia.AstRight))
		} else { // TODO will need to differentiate better between a real property or an obj-dict-key
			if cia.Indexer.AstTag == "Var" {
				if mod := findModuleByPName(cia.Indexer.Var); mod != nil {
					a = ªPkgSym(mod.pName, cia.AstRight.StringLiteral)
				}
			}
			if a == nil {
				dv := ªSymPs(cia.AstRight.StringLiteral, me.mod.irMeta.hasExport(cia.AstRight.StringLiteral))
				a = ªDot(me.astToIrA(cia.Indexer), dv)
			}
		}
	case "InstanceOf":
		if cia.AstRight.Var != "" {
			a = ªIs(me.astToIrA(cia.InstanceOf), cia.AstRight.Var)
		} else if cia.AstRight.Indexer != nil {
			apkgsym := me.astToIrA(cia.AstRight).(*irAPkgSym)
			a = ªIs(me.astToIrA(cia.InstanceOf), findModuleByPName(apkgsym.PkgName).qName+"."+apkgsym.Symbol)
		} else {
			panic(notImplErr("InstanceOf right-hand-side", cia.AstRight.AstTag, cia.Root.My.ImpFilePath))
		}
	default:
		panic(notImplErr("CoreImp AST tag", cia.AstTag, cia.Root.My.ImpFilePath))
	}
	if ab := a.Base(); ab != nil {
		ab.Comments = cia.Comment
	}
	return
}
