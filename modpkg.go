package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/metaleap/go-util-fs"
)

/*
Representation of a PureScript module from which a
Golang package will be generated. Hence 'modpkg'..

Holds intermediate representations in girMeta and girAst.
*/

type modPkg struct {
	reGenGIr        bool
	qName           string //	eg	Control.Monad.Eff.Uncurried, My.Main etc
	lName           string //	eg	Uncurried, Main etc
	pName           string //	eg	Control_Monad_Eff_Uncurried, My_Main etc
	srcFilePath     string //	eg	bower_components/purescript-eff/src/Control/Monad/Eff/Uncurried.purs or src/My/Main.purs etc
	impFilePath     string //	eg	output/Control.Monad.Eff.Uncurried/coreimp.json, output/My.Main/coreimp.json etc
	extFilePath     string //	eg	output/Control.Monad.Eff.Uncurried/externs.json, output/My.Main/externs.json etc
	girMetaFilePath string //	eg	output/Control.Monad.Eff.Uncurried/gonad.json, output/My.Main/gonad.json etc
	goOutDirPath    string //	eg	Control/Monad/Eff/Uncurried, My/Main etc
	goOutFilePath   string //	eg	Control/Monad/Eff/Uncurried/Uncurried.go, My/Main/Main.go etc

	girMeta       *gonadIrMeta
	girAst        *gonadIrAst
	proj          *psBowerProject // parent
	gopkgfilepath string          // full target file path (not necessarily absolute but starting with the given gopath)
	ext           *psExt
	coreimp       *coreImp
}

var (
	strReplSlash2Dot      = strings.NewReplacer("\\", ".", "/", ".")
	strReplDot2Slash      = strings.NewReplacer(".", "/")
	strReplDot2Underscore = strings.NewReplacer(".", "_")
)

func findModuleByQName(qname string) (modinfo *modPkg) {
	if modinfo = Proj.moduleByQName(qname); modinfo == nil {
		for _, dep := range Deps {
			if modinfo = dep.moduleByQName(qname); modinfo != nil {
				return
			}
		}
	}
	return
}

func findModuleByPName(pname string) (modinfo *modPkg) {
	if modinfo = Proj.moduleByPName(pname); modinfo == nil {
		for _, dep := range Deps {
			if modinfo = dep.moduleByPName(pname); modinfo != nil {
				return
			}
		}
	}
	return
}

func (me *modPkg) loadPkgGIrMeta() (err error) {
	var jsonbytes []byte
	if jsonbytes, err = ioutil.ReadFile(me.girMetaFilePath); err == nil {
		if err = json.Unmarshal(jsonbytes, &me.girMeta); err == nil {
			me.girMeta.populateFromLoaded()
		}
	}
	return
}

func (me *modPkg) reGenPkgGIrMeta() (err error) {
	var jsonbytes []byte
	if jsonbytes, err = ioutil.ReadFile(me.extFilePath); err == nil {
		if err = json.Unmarshal(jsonbytes, &me.ext); err == nil {
			if jsonbytes, err = ioutil.ReadFile(me.impFilePath); err == nil {
				if err = json.Unmarshal(jsonbytes, &me.coreimp); err == nil {
					me.coreimp.mod = me
					girmeta := gonadIrMeta{save: true, mod: me, proj: me.proj}
					girmeta.populateFromCoreImp()
					me.girMeta = &girmeta
				}
			}
		}
	}
	return
}

func (me *modPkg) prepGIrAst() {
	me.coreimp.preProcessTopLevel()
	me.girAst = &gonadIrAst{mod: me, proj: me.proj, girM: me.girMeta}
	me.girAst.prepFromCoreImp()
}

func (me *modPkg) reGenPkgGIrAst() (err error) {
	me.girAst.finalizePostPrep()
	var buf bytes.Buffer
	if Flag.DumpAst {
		if err = me.girAst.writeAsJsonTo(&buf); err == nil {
			err = ufs.WriteBinaryFile(me.girMetaFilePath[:len(me.girMetaFilePath)-len(".json")]+".ast.json", buf.Bytes())
		}
		buf.Reset()
	}
	if err == nil {
		if !Flag.NoPrefix {
			fmt.Fprintf(&buf, "// Generated by gonad from: %s, generated from: %s\n", me.impFilePath, me.srcFilePath)
		}
		if err = me.girAst.writeAsGoTo(&buf); err == nil {
			err = ufs.WriteBinaryFile(me.gopkgfilepath, buf.Bytes())
		}
	}
	return
}
