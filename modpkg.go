package main

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"path/filepath"
	"strings"
	"sync"

	"github.com/metaleap/go-util-fs"
)

type ModuleInfo struct {
	regenerate    bool
	qName         string //	eg	Control.Monad.Eff.Uncurried
	lName         string //	eg	Uncurried
	pName         string //	eg	Control_Monad_Eff_Uncurried
	srcFilePath   string //	eg	bower_components/purescript-eff/src/Control/Monad/Eff/Uncurried.purs
	impFilePath   string //	eg	output/Control.Monad.Eff.Uncurried/coreimp.json
	extFilePath   string //	eg	output/Control.Monad.Eff.Uncurried/externs.json
	goOutDirPath  string //	eg	Control/Monad/Eff/Uncurried
	goOutFilePath string //	eg	Control/Monad/Eff/Uncurried/Uncurried.go

	proj          *BowerProject
	gopkgfilepath string //	full target file path (not necessarily absolute but starting with the applicable gopath)
}

var (
	slash2dot      = strings.NewReplacer("\\", ".", "/", ".")
	dot2underscore = strings.NewReplacer(".", "_")
)

func FindModuleByQName(qname string) (modinfo *ModuleInfo) {
	if modinfo = Proj.ModuleByQName(qname); modinfo == nil {
		for _, dep := range Deps {
			if modinfo = dep.ModuleByQName(qname); modinfo != nil {
				return
			}
		}
	}
	return
}

func (me *BowerProject) ModuleByQName(qname string) *ModuleInfo {
	for _, m := range me.Modules {
		if m.qName == qname {
			return m
		}
	}
	return nil
}

func (me *BowerProject) AddModuleInfoFromPursFileIfCoreimp(relpath string, gopkgdir string) {
	i, l := strings.LastIndexAny(relpath, "/\\"), len(relpath)-5
	modinfo := &ModuleInfo{
		proj: me, srcFilePath: filepath.Join(me.SrcDirPath, relpath),
		qName: slash2dot.Replace(relpath[:l]), lName: relpath[i+1 : l],
	}
	if modinfo.impFilePath = filepath.Join(Proj.DumpsDirProjPath, modinfo.qName, "coreimp.json"); ufs.FileExists(modinfo.impFilePath) {
		modinfo.pName = dot2underscore.Replace(modinfo.qName)
		modinfo.extFilePath = filepath.Join(Proj.DumpsDirProjPath, modinfo.qName, "externs.json")
		modinfo.goOutDirPath = relpath[:l]
		modinfo.goOutFilePath = filepath.Join(modinfo.goOutDirPath, modinfo.lName) + ".go"
		modinfo.gopkgfilepath = filepath.Join(gopkgdir, modinfo.goOutFilePath)
		if !ufs.FileExists(modinfo.gopkgfilepath) {
			modinfo.regenerate = true
		} else if ufs.FileExists(modinfo.impFilePath) {
			modinfo.regenerate, _ = ufs.IsNewerThan(modinfo.impFilePath, modinfo.gopkgfilepath)
		}
		me.Modules = append(me.Modules, modinfo)
	}
}

func (me *BowerProject) RegenerateModulePkgs() (err error) {
	for _, modinfo := range me.Modules {
		if modinfo.regenerate || Flag.ForceRegenAll {
			if err = ufs.EnsureDirExists(filepath.Dir(modinfo.gopkgfilepath)); err != nil {
				return
			}
		}
	}
	var wg sync.WaitGroup
	regenmodulepkg := func(modinfo *ModuleInfo) {
		defer wg.Done()
		if e := modinfo.regenerateGoPkg(me); e != nil {
			panic(e)
		}
	}
	for _, modinfo := range me.Modules {
		if modinfo.regenerate || Flag.ForceRegenAll {
			wg.Add(1)
			go regenmodulepkg(modinfo)
		}
	}
	wg.Wait()
	return
}

func (me *ModuleInfo) regenerateGoPkg(proj *BowerProject) (err error) {
	var buf bytes.Buffer
	var jsonbytes []byte
	var coreimp CoreImp
	if jsonbytes, err = ioutil.ReadFile(me.impFilePath); err == nil {
		jsonstr := strings.TrimSpace(string(jsonbytes))[1:]
		jsonstr = jsonstr[:len(jsonstr)-1]
		jsonstr = jsonstr[strings.IndexRune(jsonstr, '{'):]
		if err = json.Unmarshal([]byte(jsonstr), &coreimp); err == nil {
			if !Flag.NoPrefix {
				buf.WriteString("// Generated by gonad " + coreimp.BuiltWith + " from: " + me.impFilePath + ", generated from: " + me.srcFilePath + "\n")
			}
			pkg := GoAst{modinfo: me, proj: proj, PkgName: me.pName}
			for _, impname := range coreimp.Imports {
				if impname != "Prim" && impname != "Prelude" && impname != me.qName {
					pkg.Imports = append(pkg.Imports, FindModuleByQName(impname))
				}
			}

			var setparents func(*CoreImpAst, ...*CoreImpAst)
			setparents = func(parent *CoreImpAst, asts ...*CoreImpAst) {
				for _, a := range asts {
					if a != nil {
						a.parent = parent
						setparents(a, a.App)
						setparents(a, a.ArrayLiteral...)
						setparents(a, a.Assignment)
						setparents(a, a.Ast_appArgs...)
						setparents(a, a.Ast_body)
						setparents(a, a.Ast_decl)
						setparents(a, a.Ast_for1)
						setparents(a, a.Ast_for2)
						setparents(a, a.Ast_ifElse)
						setparents(a, a.Ast_ifThen)
						setparents(a, a.Ast_rightHandSide)
						setparents(a, a.Binary)
						setparents(a, a.Block...)
						setparents(a, a.IfElse)
						setparents(a, a.Indexer)
						setparents(a, a.InstanceOf)
						setparents(a, a.Return)
						setparents(a, a.Throw)
						setparents(a, a.Unary)
						setparents(a, a.While)
						for _, m := range a.ObjectLiteral {
							for _, expr := range m {
								setparents(a, expr)
							}
						}
					}
				}
			}
			for _, decl := range coreimp.Body {
				setparents(nil, decl)
			}

			if err = pkg.PopulateFrom(&coreimp); err == nil {
				if err = pkg.WriteTo(&buf); err == nil {
					err = ufs.WriteBinaryFile(me.gopkgfilepath, buf.Bytes())
				}
			}
		}
	}
	return
}
