package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/metaleap/go-util-fs"
)

type ModuleInfo struct {
	reGenGIr        bool
	qName           string //	eg	Control.Monad.Eff.Uncurried
	lName           string //	eg	Uncurried
	pName           string //	eg	Control_Monad_Eff_Uncurried
	srcFilePath     string //	eg	bower_components/purescript-eff/src/Control/Monad/Eff/Uncurried.purs
	impFilePath     string //	eg	output/Control.Monad.Eff.Uncurried/coreimp.json
	extFilePath     string //	eg	output/Control.Monad.Eff.Uncurried/externs.json
	girMetaFilePath string //	eg	output/Control.Monad.Eff.Uncurried/gonadmeta.json
	girAstFilePath  string //	eg	output/Control.Monad.Eff.Uncurried/gonadast.json
	goOutDirPath    string //	eg	Control/Monad/Eff/Uncurried
	goOutFilePath   string //	eg	Control/Monad/Eff/Uncurried/Uncurried.go

	girMeta       *GonadIrMeta
	girAst        *GonadIrAst
	proj          *PsBowerProject
	gopkgfilepath string //	full target file path (not necessarily absolute but starting with the applicable gopath)
	ext           *PsExt
	coreimp       *CoreImp
}

var (
	slash2dot      = strings.NewReplacer("\\", ".", "/", ".")
	dot2slash      = strings.NewReplacer(".", "/")
	dot2underscore = strings.NewReplacer(".", "_")
)

func FindModuleByQName(qname string) (modinfo *ModuleInfo) {
	if modinfo = Proj.ModuleByQName(qname); modinfo == nil {
		for _, dep := range Deps {
			if modinfo = dep.ModuleByQName(qname); modinfo != nil {
				return
			}
		}
	}
	return
}

func FindModuleByPName(pname string) (modinfo *ModuleInfo) {
	if modinfo = Proj.ModuleByPName(pname); modinfo == nil {
		for _, dep := range Deps {
			if modinfo = dep.ModuleByPName(pname); modinfo != nil {
				return
			}
		}
	}
	return
}

func (me *ModuleInfo) loadPkgGIrMeta() (err error) {
	var jsonbytes []byte
	if jsonbytes, err = ioutil.ReadFile(me.girMetaFilePath); err == nil {
		if err = json.Unmarshal(jsonbytes, &me.girMeta); err == nil {
			err = me.girMeta.PopulateFromLoaded()
		}
	}
	return
}

func (me *ModuleInfo) reGenPkgGIrMeta() (err error) {
	var jsonbytes []byte
	if jsonbytes, err = ioutil.ReadFile(me.extFilePath); err == nil {
		if err = json.Unmarshal(jsonbytes, &me.ext); err == nil {
			me.ext.modinfo = me
			if jsonbytes, err = ioutil.ReadFile(me.impFilePath); err == nil {
				// the below in case coreimp.json format reverts back again from current {..} to {"Module.Name": {..}}
				// jsonstr := strings.TrimSpace(string(jsonbytes))[1:]
				// jsonstr = jsonstr[:len(jsonstr)-1]
				// jsonstr = jsonstr[strings.IndexRune(jsonstr, '{'):]
				// jsonbytes=[]byte(jsonstr)
				if err = json.Unmarshal(jsonbytes, &me.coreimp); err == nil {
					me.coreimp.mod = me
					girmeta := GonadIrMeta{save: true, mod: me, proj: me.proj}
					if err = girmeta.PopulateFromCoreImp(); err == nil {
						me.girMeta = &girmeta
					}
				}
			}
		}
	}
	return
}

func (me *ModuleInfo) prepGIrAst() (err error) {
	if err = me.coreimp.preProcessTopLevel(); err == nil {
		me.girAst = &GonadIrAst{mod: me, proj: me.proj, girM: me.girMeta}
		err = me.girAst.PrepFromCoreImp()
	}
	return
}

func (me *ModuleInfo) reGenPkgGIrAst() (err error) {
	if err = me.girAst.FinalizePostPrep(); err == nil {
		var buf bytes.Buffer
		if err = me.girAst.WriteAsJsonTo(&buf); err == nil {
			if err = ufs.WriteBinaryFile(me.girAstFilePath, buf.Bytes()); err == nil {
				buf.Reset()
				if !Flag.NoPrefix {
					fmt.Fprintf(&buf, "// Generated by gonad %s from: %s, generated from: %s\n", me.coreimp.BuiltWith, me.impFilePath, me.srcFilePath)
				}
				if err = me.girAst.WriteAsGoTo(&buf); err == nil {
					err = ufs.WriteBinaryFile(me.gopkgfilepath, buf.Bytes())
				}
			}
		}
	}
	return
}
